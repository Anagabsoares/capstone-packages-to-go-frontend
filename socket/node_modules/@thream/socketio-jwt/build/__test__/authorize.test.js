"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const socket_io_client_1 = require("socket.io-client");
const fixture_1 = require("./fixture");
describe('authorize - with secret as string in options', () => {
    let token = '';
    beforeEach((done) => {
        fixture_1.fixtureStart(async () => {
            const response = await axios_1.default.post('http://localhost:9000/login');
            token = response.data.token;
        })
            .then(done)
            .catch((error) => {
            done(error);
        });
    });
    afterEach((done) => {
        fixture_1.fixtureStop(done);
    });
    it('should emit error with no token provided', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000');
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('no token provided');
            expect(err.data.code).toEqual('credentials_required');
            socket.close();
            done();
        });
    });
    it('should emit error with bad token format', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Format is Authorization: Bearer [token]');
            expect(err.data.code).toEqual('credentials_bad_format');
            socket.close();
            done();
        });
    });
    it('should emit error with unauthorized handshake', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'Bearer testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Unauthorized: Token is missing or invalid Bearer');
            expect(err.data.code).toEqual('invalid_token');
            socket.close();
            done();
        });
    });
    it('should connect the user', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: `Bearer ${token}` }
        });
        socket.on('connect', () => {
            socket.close();
            done();
        });
        socket.on('connect_error', (err) => {
            done(err);
        });
    });
});
const secretCallback = async () => {
    return 'somesecret';
};
describe('authorize - with secret as callback in options', () => {
    let token = '';
    beforeEach((done) => {
        fixture_1.fixtureStart(async () => {
            const response = await axios_1.default.post('http://localhost:9000/login');
            token = response.data.token;
        }, { secret: secretCallback })
            .then(done)
            .catch((error) => {
            done(error);
        });
    });
    afterEach((done) => {
        fixture_1.fixtureStop(done);
    });
    it('should emit error with no token provided', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000');
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('no token provided');
            expect(err.data.code).toEqual('credentials_required');
            socket.close();
            done();
        });
    });
    it('should emit error with bad token format', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Format is Authorization: Bearer [token]');
            expect(err.data.code).toEqual('credentials_bad_format');
            socket.close();
            done();
        });
    });
    it('should emit error with unauthorized handshake', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'Bearer testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Unauthorized: Token is missing or invalid Bearer');
            expect(err.data.code).toEqual('invalid_token');
            socket.close();
            done();
        });
    });
    it('should connect the user', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: `Bearer ${token}` }
        });
        socket.on('connect', () => {
            socket.close();
            done();
        });
        socket.on('connect_error', (err) => {
            done(err);
        });
    });
});
describe('authorize - with onAuthentication callback in options', () => {
    let token = '';
    let wrongToken = '';
    beforeEach((done) => {
        fixture_1.fixtureStart(async () => {
            const response = await axios_1.default.post('http://localhost:9000/login');
            token = response.data.token;
            const responseWrong = await axios_1.default.post('http://localhost:9000/login-wrong');
            wrongToken = responseWrong.data.token;
        }, {
            secret: secretCallback,
            onAuthentication: (decodedToken) => {
                if (!decodedToken.checkField) {
                    throw new Error('Check Field validation failed');
                }
                return {
                    email: decodedToken.email
                };
            }
        })
            .then(done)
            .catch((error) => {
            done(error);
        });
    });
    afterEach((done) => {
        fixture_1.fixtureStop(done);
    });
    it('should emit error with no token provided', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000');
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('no token provided');
            expect(err.data.code).toEqual('credentials_required');
            socket.close();
            done();
        });
    });
    it('should emit error with bad token format', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Format is Authorization: Bearer [token]');
            expect(err.data.code).toEqual('credentials_bad_format');
            socket.close();
            done();
        });
    });
    it('should emit error with unauthorized handshake', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: 'Bearer testing' }
        });
        socket.on('connect_error', (err) => {
            expect(err.data.message).toEqual('Unauthorized: Token is missing or invalid Bearer');
            expect(err.data.code).toEqual('invalid_token');
            socket.close();
            done();
        });
    });
    it('should connect the user', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: `Bearer ${token}` }
        });
        socket.on('connect', () => {
            socket.close();
            done();
        });
    });
    it('should contain user property', (done) => {
        const socketServer = fixture_1.getSocket();
        socketServer?.on('connection', (client) => {
            expect(client.user.email).toEqual('john@doe.com');
        });
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: `Bearer ${token}` }
        });
        socket.on('connect', () => {
            socket.close();
            done();
        });
    });
    it('should emit error when user validation fails', (done) => {
        const socket = socket_io_client_1.io('http://localhost:9000', {
            auth: { token: `Bearer ${wrongToken}` }
        });
        socket.on('connect_error', (err) => {
            try {
                expect(err.message).toEqual('Check Field validation failed');
            }
            catch (err) {
                socket.close();
                done(err);
            }
            socket.close();
            done();
        });
    });
});
