"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authorize = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const UnauthorizedError_1 = require("./UnauthorizedError");
const authorize = (options) => {
    const { secret, algorithms = ['HS256'], onAuthentication } = options;
    return async (socket, next) => {
        let encodedToken = null;
        const { token } = socket.handshake.auth;
        if (token != null) {
            const tokenSplitted = token.split(' ');
            if (tokenSplitted.length !== 2 || tokenSplitted[0] !== 'Bearer') {
                return next(new UnauthorizedError_1.UnauthorizedError('credentials_bad_format', {
                    message: 'Format is Authorization: Bearer [token]'
                }));
            }
            encodedToken = tokenSplitted[1];
        }
        if (encodedToken == null) {
            return next(new UnauthorizedError_1.UnauthorizedError('credentials_required', {
                message: 'no token provided'
            }));
        }
        socket.encodedToken = encodedToken;
        let keySecret = null;
        let decodedToken;
        if (typeof secret === 'string') {
            keySecret = secret;
        }
        else {
            const completeDecodedToken = jsonwebtoken_1.default.decode(encodedToken, { complete: true });
            keySecret = await secret(completeDecodedToken);
        }
        try {
            decodedToken = jsonwebtoken_1.default.verify(encodedToken, keySecret, { algorithms });
        }
        catch {
            return next(new UnauthorizedError_1.UnauthorizedError('invalid_token', {
                message: 'Unauthorized: Token is missing or invalid Bearer'
            }));
        }
        socket.decodedToken = decodedToken;
        if (onAuthentication != null) {
            try {
                socket.user = await onAuthentication(decodedToken);
            }
            catch (err) {
                return next(err);
            }
        }
        return next();
    };
};
exports.authorize = authorize;
